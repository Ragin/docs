import React, { useMemo, useState, useEffect } from 'react';
import {
  Grid,
  Card,
  CardContent,
  Typography,
  FormControl,
  Select,
  FormHelperText,
  TextField
} from '@mui/material';
import { styled } from '@mui/material/styles';
import { useMemberModalContext } from '../../../Member/Components/AddmemberModal/useMemberModal';
import { getData } from '../../../model/service/memberService';
import { FieldType } from './header-component';

export const labelHeadingStyle = {
  fontWeight: 'bold',
  color: 'black'
};

export const labelStyle = {
  fontWeight: 'bold',
  color: '#3F51B5'
};

const StyledCard = styled(Card)`
  margin-bottom: 10px;

  &:last-child {
    margin-bottom: 0;
  }
`;

const formatDate = (dateString: string) => {
  const [month, day, year] = dateString.split('/');
  return `${year}-${(month ?? '').padStart(2, '0')}-${(day ?? '').padStart(2, '0')}`;
};

interface FieldRendererProps {
  field: any;
  value: any;
  data: any;
  handleInputChange: (fieldName: string, value: any) => void;
  dmErrors: any;
  isAddMode: boolean;
  isEditMode: boolean;
}

const FieldRenderer: React.FC<FieldRendererProps> = React.memo(
  ({ field, value, data, handleInputChange, dmErrors, isAddMode, isEditMode }) => {
    const [options, setOptions] = useState<any[]>([]);

    useEffect(() => {
      // Set the initial value for the field.
      handleInputChange(
        field.apikey || field,
        !data?.[field.name] || data?.[field.name].trim() === '' ? '' : data?.[field.name].trim()
      );
      if (field?.optionsUrl) {
        getData(field.optionsUrl, { sid: data?.sid, 'auth-type': undefined })
          .then((response) => {
            setOptions(response?.data?.optionsList || []);
          })
          .catch((error) => {
            console.error('Error fetching options:', error);
          });
      } else {
        setOptions(field?.options || []);
      }
    }, [field, data, handleInputChange]);

    // In Add Mode
    if (isAddMode && !field.readOnly) {
      if (field.type === 'select') {
        return (
          <FormControl sx={{ width: '70%' }}>
            <Select
              native
              name={field.apikey}
              onChange={(e) =>
                handleInputChange(field.apikey || field, e.target.value)
              }
              error={Boolean(dmErrors?.[field.apikey])}
              MenuProps={{ classes: { paper: 'skyline-custom-select' } }}
              label="Status"
            >
              <option value="">Select</option>
              {options.map((current: any, idx: number) => {
                const optionName =
                  typeof current === 'string' ? current : current.name;
                const optionValue =
                  typeof current === 'string' ? current : current.value;
                return (
                  <option key={idx} value={optionName}>
                    {optionValue}
                  </option>
                );
              })}
            </Select>
            <FormHelperText error={Boolean(dmErrors?.[field.apikey])}>
              {dmErrors?.[field.apikey] ? `${field.label} is required` : ''}
            </FormHelperText>
          </FormControl>
        );
      } else {
        return (
          <TextField
            type={field.type || 'text'}
            variant="outlined"
            name={field.apikey || field}
            inputProps={{ maxLength: field?.maxLength }}
            error={Boolean(dmErrors?.[field.apikey])}
            helperText={
              dmErrors?.[field.apikey] ? `${field.label} is required` : ''
            }
            onChange={(e) =>
              handleInputChange(field.apikey || field, e.target.value)
            }
            sx={{
              width: '70%',
              '& legend': { display: 'none' },
              '& fieldset': { top: 0 }
            }}
          />
        );
      }
    }

    // In Edit Mode
    if (isEditMode && !field.readOnly) {
      if (field.type === 'select') {
        // Split the value if it contains a " - "
        const [selectedName] = (data?.[field.name] || '').includes(' - ')
          ? (data?.[field.name] || '').split(' - ')
          : [data?.[field.name], ''];
        return (
          <FormControl sx={{ width: '70%' }}>
            <Select
              native
              name={field.apikey}
              value={selectedName}
              onChange={(e) =>
                handleInputChange(field.apikey || field, e.target.value)
              }
              error={Boolean(dmErrors?.[field.apikey])}
              MenuProps={{ classes: { paper: 'skyline-custom-select' } }}
              label="Status"
            >
              <option value="">Select</option>
              {options.map((current: any, idx: number) => {
                const optionName =
                  typeof current === 'string' ? current : current.name;
                const optionValue =
                  typeof current === 'string' ? current : current.value;
                return (
                  <option key={idx} value={optionName}>
                    {optionValue}
                  </option>
                );
              })}
            </Select>
            <FormHelperText error={Boolean(dmErrors?.[field.apikey])}>
              {dmErrors?.[field.apikey] ? `${field.label} is required` : ''}
            </FormHelperText>
          </FormControl>
        );
      }
      if (field.name === 'originalEffDate') {
        return (
          <div style={{ marginBottom: '15px', marginRight: '15px' }}>
            <Typography variant="body1">{data?.originalEffDate}</Typography>
          </div>
        );
      }
      if (field.name === 'benefitResetDate') {
        return (
          <div style={{ marginBottom: '15px', marginRight: '15px' }}>
            <Typography variant="body1">{data?.benefitResetDate}</Typography>
          </div>
        );
      }
      if (field.name === 'dob') {
        let dobFormatted =
          !data?.[field.name] || data?.[field.name].trim() === ''
            ? ''
            : data?.[field.name].trim();
        dobFormatted = formatDate(dobFormatted);
        return (
          <TextField
            type={field.type || 'text'}
            variant="outlined"
            name={field.apikey || field}
            inputProps={{
              maxLength: field?.maxLength,
              defaultValue: dobFormatted,
              style: { textTransform: 'uppercase' }
            }}
            error={Boolean(dmErrors?.[field.apikey])}
            helperText={dmErrors?.[field.apikey] ? 'This field is required' : ''}
            onChange={(e) =>
              handleInputChange(field.apikey || field, e.target.value)
            }
            sx={{
              width: '70%',
              '& legend': { display: 'none' },
              '& fieldset': { top: 0 }
            }}
          />
        );
      }
      if (field.name === 'familyInd') {
        return (
          <TextField
            type={field.type || 'text'}
            variant="outlined"
            name={field.apikey || field}
            inputProps={{
              maxLength: field?.maxLength,
              defaultValue:
                !data?.[field.name] || data?.[field.name].trim() === ''
                  ? ''
                  : data?.[field.name].trim().charAt(0),
              style: { textTransform: 'uppercase' }
            }}
            error={Boolean(dmErrors?.[field.apikey])}
            helperText={dmErrors?.[field.apikey] ? 'This field is required' : ''}
            onChange={(e) =>
              handleInputChange(field.apikey || field, e.target.value)
            }
            sx={{
              width: '70%',
              '& legend': { display: 'none' },
              '& fieldset': { top: 0 }
            }}
          />
        );
      }
      return (
        <TextField
          type={field.type || 'text'}
          variant="outlined"
          name={field.apikey || field}
          inputProps={{
            maxLength: field?.maxLength,
            defaultValue:
              !data?.[field.name] || data?.[field.name].trim() === ''
                ? ''
                : data?.[field.name].trim(),
            style: { textTransform: 'uppercase' }
          }}
          error={Boolean(dmErrors?.[field.apikey])}
          helperText={dmErrors?.[field.apikey] ? 'This field is required' : ''}
          onChange={(e) =>
            handleInputChange(field.apikey || field, e.target.value)
          }
          sx={{
            width: '70%',
            '& legend': { display: 'none' },
            '& fieldset': { top: 0 }
          }}
        />
      );
    }

    // Read-only display
    return <Typography variant="body2">{value || ''}</Typography>;
  }
);

interface SimpleLayoutComponentProps {
  data: any;
  labels: FieldType;
  layout: any;
  style?: any;
  cols?: number;
  addMemberFormData: any;
  dmErrors: any;
  handleInputChange: (fieldName: string, value: any) => void;
  isEdit?: boolean;
}

const SimpleLayoutComponent: React.FC<SimpleLayoutComponentProps> = ({
  data,
  labels,
  layout,
  cols = 3,
  handleInputChange,
  dmErrors
}) => {
  // Memoize the provided layout to avoid unnecessary re-renders.
  const computedLayout = useMemo(() => layout, [layout]);
  const { isAddMode, isEditMode } = useMemberModalContext();

  return (
    <Grid container spacing={2}>
      <Grid item xs={12}>
        <Card elevation={3}>
          <Grid container spacing={2}>
            <Grid item xs={12}>
              {computedLayout.leftLayout.map((group: { heading: string; fields: any[] }) => (
                <StyledCard elevation={3} key={group.heading}>
                  <Card>
                    <CardContent>
                      <Grid container spacing={1}>
                        <Grid item xs={12}>
                          <span />
                        </Grid>
                        <Grid item xs={12}>
                          <Typography variant="h6" style={labelHeadingStyle}>
                            {labels[group.heading as keyof typeof labels] ||
                              group.heading.replace(/\${(.*?)}/g, '')}
                          </Typography>
                        </Grid>
                        {group.fields.map((field: any, idx: number) => {
                          if (typeof field === 'string') {
                            return (
                              <Grid item xs={12} sm={cols} md={cols} key={idx}>
                                <div style={{ marginBottom: '15px' }}>
                                  <Typography variant="subtitle1" style={labelStyle}>
                                    {(labels as Record<string, string>)[field] || ''}
                                  </Typography>
                                  <Typography variant="body1" sx={{ display: 'block' }}>
                                    {data?.[field]}
                                  </Typography>
                                </div>
                              </Grid>
                            );
                          } else {
                            return (
                              <Grid item xs={12} sm={cols} md={cols} key={idx}>
                                <div style={{ marginBottom: '15px' }}>
                                  <Typography variant="subtitle1" style={labelStyle}>
                                    {(labels as Record<string, string>)[field.name] || field.name}
                                    {(isAddMode || isEditMode) && field.required && (
                                      <span style={{ color: 'red' }}>*</span>
                                    )}
                                  </Typography>
                                  <Typography variant="body1">
                                    <FieldRenderer
                                      field={field}
                                      value={data?.[field.name] || ''}
                                      data={data}
                                      handleInputChange={handleInputChange}
                                      dmErrors={dmErrors}
                                      isAddMode={isAddMode}
                                      isEditMode={isEditMode}
                                    />
                                  </Typography>
                                </div>
                              </Grid>
                            );
                          }
                        })}
                      </Grid>
                    </CardContent>
                  </Card>
                </StyledCard>
              ))}
            </Grid>
          </Grid>
        </Card>
      </Grid>
    </Grid>
  );
};

export default SimpleLayoutComponent;

===

import React, { useMemo, useState, useEffect } from 'react';
import { AppBar, Button, Grid, Toolbar, Typography, Box } from '@mui/material';
import useMemberDetail, { MemberDetailContext } from '../useMemberDetail/use-member-detail';
import labels from '../../common/labels.json';
import { MemberDetailSearchRecord } from '../useMemberDetail/use-member-detail.types';
import { MemberContext, RxMemberLiteContext } from '../../common/model-types';
import StatusFilter from '../../common/status-filter';
import { isFromClientPortal, setAuthTypeClientPortal } from '../../common/common-utils';
import { useMemberModalContext } from '../../Member/Components/AddmemberModal/useMemberModal';
import { postData2, getData } from '../../model/service/memberService';
import MemberDetailTabs from './components/member-detail-tabs';
import HeaderComponent from './components/header-component';
import { ElgData, MemberDetailsProps, MemberNamesInputs } from './member-detail.types';
import MemberEligibilityModal from './MemberEligibilityModal';
import MemEligibilityExpandableTable from './components/member-eligibility/member-eligibility-expandable-table';

const title = '${memberId} (${lastName}, ${firstName} ${middleName})';

const leftLayout = [
  {
    heading: 'Member information ${}',
    fields: [
      {
        name: 'dob',
        required: false,
        readOnly: false,
        type: 'date',
        apikey: 'mbrDateOfBirth',
        label: 'Date of birth'
      },
      {
        name: 'sex',
        required: false,
        readOnly: false,
        type: 'select',
        apikey: 'mbrSex',
        label: 'Gender',
        optionsUrl: '/lookup-url?lookupType=GENDER'
      },
      {
        name: 'personCd',
        readOnly: false,
        required: false,
        type: 'text',
        apikey: 'mbrPersonCode',
        maxLength: 3,
        label: 'Person code'
      },
      {
        name: 'relationshipCd',
        readOnly: false,
        type: 'select',
        required: false,
        apikey: 'mbrRelationshipCode',
        label: 'Relationship code',
        optionsUrl: '/lookup-url?lookupType=MEMBER_RELATIONSHIP_CODE'
      },
      {
        name: 'memberType',
        readOnly: false,
        label: 'Member type',
        type: 'select',
        required: false,
        apikey: 'mbrMemberType',
        optionsUrl: '/lookup-url?lookupType=MEMBER_TYPE'
      },
      {
        name: 'multiBirthCd',
        label: 'Multiple birth code',
        readOnly: false,
        type: 'text',
        apikey: 'mbrMultipleBirthCode',
        required: false,
        maxLength: 1
      },
      {
        name: 'language',
        label: 'Language',
        readOnly: false,
        type: 'select',
        apikey: 'mbrLanguageCode',
        required: false,
        optionsUrl: '/lookup-url?lookupType=LANGUAGE'
      },
      {
        name: 'ssn',
        label: 'SSN',
        readOnly: false,
        type: 'text',
        apikey: 'mbrSs',
        required: false,
        maxLength: 11
      },
      {
        name: 'phone',
        label: 'Phone',
        readOnly: false,
        type: 'text',
        apikey: 'mbrPhone',
        required: false,
        maxLength: 10
      },
      {
        name: 'email',
        label: 'Email',
        readOnly: false,
        type: 'email',
        apikey: 'mbrEmailAddress',
        required: false,
        maxLength: 80
      },
      {
        name: 'originalEffDate',
        label: 'Original from date',
        readOnly: false,
        type: 'date',
        apikey: 'mbrOriginalEffDate',
        required: false
      },
      {
        name: 'benefitResetDate',
        label: 'Benefit reset date',
        readOnly: false,
        type: 'date',
        apikey: 'mbrBenefitResetDate',
        required: false
      },
      {
        name: 'familyInd',
        label: 'Family ind',
        readOnly: false,
        type: 'select',
        apikey: 'mbrFamilyIndicator',
        required: false,
        options: ['Y - Yes', 'N - No']
      },
      {
        name: 'familyId',
        label: 'Family ID',
        readOnly: false,
        type: 'text',
        apikey: 'mbrFamilyId',
        maxLength: 18,
        required: false
      },
      {
        name: 'durKey',
        label: 'DUR',
        readOnly: false,
        type: 'text',
        apikey: 'mbrDurKey',
        maxLength: 18,
        required: false
      }
    ]
  },
  {
    heading: 'Address ${}',
    fields: [
      {
        name: 'address1',
        label: 'Address 1',
        type: 'text',
        readOnly: false,
        apikey: 'mbrAddress1',
        maxLength: 40,
        required: false
      },
      {
        name: 'address2',
        label: 'Address 2',
        type: 'text',
        readOnly: false,
        apikey: 'mbrAddress2',
        maxLength: 40,
        required: false
      },
      {
        name: 'address3',
        label: 'Address 3',
        type: 'text',
        readOnly: false,
        apikey: 'mbrAddress3',
        maxLength: 40,
        required: false
      },
      {
        name: 'city',
        label: 'City',
        type: 'text',
        readOnly: false,
        apikey: 'mbrCity',
        maxLength: 20,
        required: false
      },
      {
        name: 'state',
        label: 'State',
        type: 'select',
        readOnly: false,
        apikey: 'mbrState',
        required: false,
        optionsUrl: '/lookup-url?lookupType=STATE'
      },
      {
        name: 'zip1',
        label: 'Zip 1',
        type: 'text',
        readOnly: false,
        apikey: 'mbrZip',
        maxLength: 5,
        required: false
      },
      {
        name: 'zip2',
        label: 'Zip 2',
        type: 'text',
        readOnly: false,
        apikey: 'mbrZip2',
        maxLength: 4,
        required: false
      },
      {
        name: 'zip3',
        label: 'Zip 3',
        type: 'text',
        readOnly: false,
        apikey: 'mbrZip3',
        maxLength: 2,
        required: false
      },
      {
        name: 'country',
        label: 'Country',
        type: 'select',
        readOnly: false,
        apikey: 'mbrCountry',
        maxLength: 4,
        required: false,
        optionsUrl: '/lookup-url?lookupType=COUNTRY'
      }
    ]
  },
  {
    heading: 'Medicare ${}',
    fields: ['supplementalId', 'msiFromDate', 'msiThruDate', 'msiStatus']
  },
  {
    heading: 'Alternate insurance ${}',
    fields: ['insuranceFlag', 'insuranceId', 'insuranceCode']
  }
];

const eligibilityLayout: any = {
  heading: 'Add Member Eligibility',
  fields: [
    {
      name: 'melEffDate',
      label: 'melEffDate',
      type: 'date',
      required: true,
      readOnly: false,
      apikey: 'melEffDate'
    },
    {
      name: 'melThruDate',
      label: 'melThruDate',
      type: 'date',
      required: true,
      readOnly: false,
      apikey: 'melThruDate'
    },
    {
      name: 'melClientProductCode',
      label: 'melClientProductCode',
      type: 'text',
      readOnly: false,
      apikey: 'melClientProductCode',
      maxLength: 6
    },
    {
      name: 'melClientRiderCode',
      label: 'melClientRiderCode',
      type: 'text',
      readOnly: false,
      apikey: 'melClientRiderCode',
      maxLength: 6
    }
  ]
};

export type Field = {
  name: string;
  readOnly?: boolean;
  type?: string;
  apikey?: string;
  required?: boolean;
  maxLength?: number;
};

export type Group = {
  heading: string;
  fields: (string | Field)[];
};

const layout = {
  title,
  leftLayout
};

const memEligHeadingLayoutFields = [
  'effDate',
  'thruDate',
  'planCode',
  'copayBrand',
  'copayGen',
  'copay3',
  'copay4',
  'status'
];

const memEligExpandedLayout = [
  {
    heading: '',
    fields: [
      'clientProductCode',
      'clientRiderCode',
      'spendDownAmount',
      'effDetDate',
      'addDate',
      'chgDate',
      'user'
    ]
  }
];

export function openHelp() {
  const helpPage =
    'https://rxclaim-lite.optum.com/rxclaimlite/help/RxClaim_Lite/index.htm#t=Topics%2FManage_members%2FMember_information_detail.htm';
  window.open(helpPage, 'Help');
}

export function scrollToTop() {
  const scrollingDiv = document
    .querySelector('member-mp')
    ?.querySelector('div')
    ?.querySelector('div')
    ?.querySelector('div')
    ?.shadowRoot?.querySelector('div')
    ?.querySelector('#scrollingMemberDiv');
  console.log('scrollingDiv', scrollingDiv);
  scrollingDiv?.scrollTo(0, 0);
}

export default layout;
export { leftLayout, eligibilityLayout, memEligHeadingLayoutFields, memEligExpandedLayout };
